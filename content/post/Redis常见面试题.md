---
title: "Redis常见面试题"
date: 2020-12-22T21:29:59+08:00
draft: false
categories:
  - Redis
  - NoSQL
  - 数据库
tags:
  - Redis
  - 中间件
  - NoSQL
  - 数据库
---

# 原理篇

## 如何理解Redis的通讯协议resp协议
    {{< spoiler >}} 

    {{< / spoiler >}}

## 如何理解Redis的cluster bus的gossip协议

    {{< spoiler >}} 
    1）用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间；
    2）gossip 协议包含多种消息，包含 ping、pong、meet、fail 等等；
    3）ping ： 每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据；
    4）meet ： 某个节点发送 meet 给新加入的节点，让新节点加入集群中；
    5）pong ： 返回meet和ping；
    6）fail ： 节点停止后发送fail告知其他节点；
    {{< / spoiler >}}

## 为什么早期版本Redis是单线程的

    {{< spoiler >}} 
    Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽
    {{< / spoiler >}}

## Redis为什么速度快

    {{< spoiler >}} 
    1）绝大部分操作为基于内存的操作
    2）数据结构和对数据的操作简单
    3）采用单线程减少上下文切换和竞争，不需要考虑锁的问题
    4）使用多路I/O复用模型，非阻塞IO，多个网络连接使用同一个线程
    5）通过队列将访问串形化，减少传统关系型数据的串行控制开销
    {{< / spoiler >}}

## Redis的主从复制原理是什么

    {{< spoiler >}} 
    
    从节点连接主节点，向主节点发起同步请求，接收主节点的rdb文件
    
    {{< / spoiler >}}

6. Redis如何划分内存

    {{< spoiler >}} 
    1）used_memory ：Redis分配器分配的内存总量；
    2）used_memory_rss ：进程占据操作系统的内存；
    3）mem_fragmentation_ratio ： 内存碎片率，used_memory_rss / used_memory；
    4）mem_allocator ： 使用的内存分配器
    {{< / spoiler >}}
    
7. Redis的存储细节

    {{< spoiler >}} 

    {{< / spoiler >}}
    
8. Redis如何实现渐进式hash进行扩容

    

    {{< spoiler >}} 
    
    1）申请旧hash两倍的内存空间，使得原有的字典同时持有旧hash表和新hash表
    
    2）维护一个标志变量rehashindex用于记录进度
    
    3）访问字典时将旧hash表中位于rehashindex这个桶中的key全部转移到新hash表中
    
    4）全部转移完时修改记录进度rehashindex
    
    {{< / spoiler >}}
    
    
    
9. Redis事务的CAS

    {{< spoiler >}} 

    {{< / spoiler >}}

10. string如何扩容

    {{< spoiler >}} 
    小于1m时每次加倍扩容，大于1m时每次增加1m，最大为512m
    {{< / spoiler >}}

11. redis的文件事件处理器都包含哪些部分

     {{< spoiler >}} 
     1）多个 socket用来完成请求的接收与响应信息的发送
     2）IO 多路复用程序
     3）文件事件分派器用来协调调度
     4）事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）用来真正干活
     {{< / spoiler >}}

# 基础篇

1. Redis都有哪些基础的数据结构，他们各自的底层是如何实现的，对应的使用场景是什么

    {{< spoiler >}} 
    1）String ： 类似Java的动态数组，在内部预先分配一定空间，场景为存储键值对；
    2）Hash ： 类似Java的HashMap，数据+链表结构，发生 hash 碰撞时将会把元素追加到链表上，场景为存储购物车信息或者对象；
    3）List ： 类似Java的LinkedList，插入与删除数据的复杂度为O(1),数据量少时为一块内存连续的ziplist，数据量多时采用有前后指针的quicklist，redis3.2以后是ziplist+quicklist，场景为点赞列表、评论列表；
    4）Set ： 类似Java的HashSet，键无序且唯一，value为null，场景为好友、关注、粉丝、感兴趣的人集合；
    5）SortedSet ：有序集合，内部实现为ziplist或者skiplist，场景为排行榜
    {{< / spoiler >}}

2. Redis有哪些高级的数据结构，对应的使用场景是什么

    {{< spoiler >}}
    1)BitMaps : 位图,面向bit进行操作,每个bit位为一个值,极度节省空间,经典使用场景是用户的每日签到记录
    2)HyperLogLog : 基数统计,基数是数据集去重后元素个数,经典使用场景是统计用户UV
    3)GEO : 处理地理位置
    {{< /spoiler >}}

3. Redis如何做到数据持久化，这些方式各自有什么优缺点

    {{< spoiler >}} 
    RDB保存快照，AOF保存执行命令的记录并合并命令；
    1) RDB有两种方式：同步save模式和异步bgsave模式，同步save模式可以保证数据一致性；
    save会导致redis阻塞，bgsave在大数据量时fork会引起抖动，导致短暂时间内redis响应变慢，且fork需要一定的内存开销；
    rdb文件默认每次rdb时进行替换并压缩；
    rdb优点：文件紧凑，体积小，适合全量备份与复制，且加载rdb文件的速度比加载aof文件的速度快
    rdb缺点：无法秒级别持久化，老版本redis无法兼容新版本的rdb
    2) aof是目前主流的持久数据的方式，aof每次都会将写命令保存到缓冲区然后追加输出到aof文件中，
    {{< / spoiler >}}


​    
5. Redis慢查询如何开启

    {{< spoiler >}} 
    设置slowlog-log-slower-than属性来配置慢查询时间的阈值，设置slowlog-max-len属性来配置存储多少条慢查询命令
    {{< / spoiler >}}
    
6. Redis的默认内存为多大

    {{< spoiler >}} 
    32位机器默认3个G，64位机器默认不限制
    {{< / spoiler >}}
    
7. Redis的淘汰策略有哪些

    {{< spoiler >}} 
    1）noeviction ： 不删除
    2）allkeys-lru ： 从所有key中删除最近最少使用的key
    3）volatile-lru ： 从设置了过期时间的key中删除最近最少使用的key
    4）allkeys-random ： 从所有key中随机删除
    5）volatile-random ： 从设置了过期时间的key中随机删除
    6）volatile-ttl ： 从设置了过期时间的key中删除剩余时间最短的
    7）allkeys-lfu ：淘汰访问频率最低的key
    8）volatile-lfu ：只淘汰访问频率最低的过期key
    {{< / spoiler >}}
    
8. Redis的删除策略有哪些，这些删除策略各自有什么优缺点

    {{< spoiler >}} 
    1）定时删除 ： 在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作，优点是对内存友好可以即时释放，缺点是对cpu不友好可能大量key同时删除；
    2）定期删除 ： 每隔一定时间删除过期的键，优点是对cpu友好，缺点是对内存不友好；
    3）惰性删除 ： 放任键过期不管，但在每次获取键时，判断是否过期，若过期再删除，优点是对cpu友好，缺点是对内存不友好
    {{< / spoiler >}}
  
9. Redis的Pipeline如何理解

    {{< spoiler >}} 
    将多个命令一次性发送并执行，节省网络消耗，虽然命令执行时可能被其他命令穿插
    {{< / spoiler >}}
  
10. Redis如何设置过期时间

    {{< spoiler >}} 
    1）expire key milliseconds在指定毫秒后过期；
    2）expire key seconds在指定秒后过期；
    3）expire at key timestamp 在指定的时间戳（秒级别）后过期；
    4）expire at key millisecondsTimestamp 在指定的时间戳（毫秒）后过期
    {{< / spoiler >}}
  
11. Redis支持哪些集群模式

    {{< spoiler >}} 

    1）主从复制模式；2）Sentinel哨兵模式；3）cluster模式
    
    {{< / spoiler >}}
    
12. Redis的事务是否支持回滚

13. Redis的事务有哪些相关命令

14. Redis有哪些常用的缓存更新策略

# 实战篇

## Redis有哪些常用场景

{{< spoiler >}} 

1）缓存

2）Session共享

3）简单的消息队列

  {{< / spoiler >}}

## 如何理解缓存穿透、缓存击穿、缓存雪崩、缓存预热，如何解决

{{< spoiler >}} 
1）缓存穿透 ： 查询一个在redis中不存在的值，比如空值或者特殊的值，解决方案：将一些不存在的值也放入redis中；采用布隆过滤器；
2）缓存击穿 ：说某个key非常热点，当这个key在失效的瞬间，大量的请求直接请求数据库，解决方案：热点数据设置为永远不过期，或者加入互斥锁
3）缓存雪崩 ： 大批量的缓存集中在某个时刻失效，解决方案：设置过期时间不一致，或者加锁排队，或者建立备份缓存或者 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 - 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。 - 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据；
4）缓存预热： 提前将常用数据加入到缓存中以提高速度
{{< / spoiler >}}

## Redis内存使用满会出现什么现象

{{< spoiler >}} 

无法写入只能读取

{{< / spoiler >}}

## 主从结构下，数据一致性问题如何解决

{{< spoiler >}} 

1）分析业务场景，若允许不一致，则无需处理

2）选择性读主：核心思路是将变动的情况写入在一个cache中，从节点从这个cache中查看是否包含本次的数据。

* 记录变化情况 ：将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”
* 查询时若cache有这个key ： 说明1s内刚发生过写请求，数据库主从同步可能还没有完成，此时就应该去主库查询
* 查询时若cache没有这个key ：说明最近没有发生过写请求，此时就可以去从库查询

{{< / spoiler >}}

## Redis如何实现定时队列

{{< spoiler >}} 

{{< / spoiler >}}

## Redis如何实现消息队列

{{< spoiler >}} 
1）基于List的 LPUSH+BRPOP 的实现，使用rpush和lpush操作入队列，lpop和rpop操作出队列，引入阻塞读blpop和brpop，阻塞读在队列没有数据的时候进入休眠状态，一旦数据到来则立刻醒过来，消息延迟几乎为零，这种方案当一直没有消息时会导致连接空闲从而被释放，下次使用连接时报错，而且也没有消费者ACK机制，也不能重复消费，也不能进行广播；
2）PUB/SUB，订阅/发布模式，广播模式，消息可以即时发送，但是若消息发布时消费者不在线会丢失小消息，消息积压时也不好处理；
3）基于Sorted Set，消息id自己实现有序递增，缺点是不能存在重复的消息id；
4）基于stream，redis5.0开始支持，借鉴kafka，采用消息链表，消息持久化，可以记录消费者的消费进度，可以确保消息至少被消费一次，但是消息过多时旧消息会丢失，消费者消费消息但不ack会导致pel列表增大而消耗内存
{{< / spoiler >}}

## Redis的并发竞争如何解决

{{< spoiler >}} 
1）多个实例更新一个key时通过加锁排队让命令串形化
{{< / spoiler >}}

## Redis和数据库如何实现双写一致性

{{< spoiler >}} 
1）Cache Aside Pattern ：

​	-读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。 

	- 更新的时候，先更新数据库，然后再删除缓存，这种方案实际上在高并发的时候可以继续进行优化
{{< / spoiler >}}

## 有哪些基于Redis实现的分布式锁

{{< spoiler >}} 
1）setnx + expire；
2）setIfAbsent；
3）基于zookeeper的有序节点实现分布式锁；
4）redssion ：采用看门狗，定期续期 ；
5）redlock ： 将加锁命令发送到多个节点参与，如果大多数都加锁成功就成功，如果失败就逐个恢复锁；
{{< / spoiler >}}

## Redis中的key过期了是否立即释放内存，为什么

{{< spoiler >}} 
不是
{{< / spoiler >}}

## 如何保证Redis的高可用和高并发

{{< spoiler >}} 
1）基于一主多从，主节点进行写入，每秒w级别的qps，从节点进行读取，每秒10w级别的qps
2）加上哨兵，当节点出现故障时进行主备切换
{{< / spoiler >}}

## Redis集群模式下，redis的key如何寻址，分布式寻址都有哪些算法

{{< spoiler >}} 
寻址算法 ： 
1）hash 算法（大量缓存重建）：计算hash后取模，访问不同的节点
2）一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） ：将整个 hash 值空间组织成一个虚拟的圆环
3）redis cluster 的 hash slot 算法 ：对每个 key 计算 CRC16 值，然后对 16384 取模，放入16384个slot中的一个，每个redis节点持有部分slot
{{< / spoiler >}}

##一致性hash算法是什么

{{< spoiler >}} 

{{< / spoiler >}}

## Redis变慢如何排查

{{< spoiler >}} 
1）查看慢命令，分析是否存在复杂命令
2）查看是否存在大key
3）查看是否缓存雪崩
4）查看淘汰策略，查看内存是否打满
5）查看fork进程频率是否合理
6）查看内存分配是否合理 
7）查看aof追加策略
8）如果是单机部署了多个redis，定位是否存在aof竞争问题
9）查看是否使用swap
10）查看网卡负载是否正常
{{< / spoiler >}}

## 如何为Redis一次增加大批量数据

 {{< spoiler >}} 

 1）管道2）手动拼接发送resp命令

 {{< / spoiler >}}

## 开发层次有哪些常用的优化建议

* key的长度尽量要短，在数据量非常大时，过长的key名会占用更多的内存；

* 一定避免存储过大的数据（大value），过大的数据在分配内存和释放内存时耗时严重，会阻塞主线程；

* Redis 4.0以上建议开启lazy-free机制，释放大value时异步操作，不阻塞主线程；

* 建议设置过期时间，把Redis当做缓存使用，尤其在数量很大的时，不设置过期时间会导致内存的无限增长；

* 不使用复杂度过高的命令，例如SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE，使用这些命令耗时较久，会阻塞主线程；

* 查询数据时，一次尽量获取较少的数据，在不确定容器元素个数的情况下，避免使用LRANGE key 0 -1，ZRANGE key 0 -1这类操作，应该设置具体查询的元素个数，推荐一次查询100个以下元素；

* 写入数据时，一次尽量写入较少的数据，例如HSET key value1 value2 value3…，控制一次写入元素的数量，推荐在100以下，大数据量分多个批次写入；

* 批量操作数据时，用MGET/MSET替换GET/SET、HMGET/MHSET替换HGET/HSET，减少请求来回的网络IO次数，降低延迟，对于没有批量操作的命令，推荐使用pipeline，一次性发送多个命令到服务端；

* 禁止使用KEYS命令，需要扫描实例时，建议使用SCAN，线上操作一定要控制扫描的频率，避免对Redis产生性能抖动

* 避免某个时间点集中过期大量的key，集中过期时推荐增加一个随机时间，把过期时间打散，降低集中过期key时Redis的压力，避免阻塞主线程；

* 根据业务场景，选择合适的淘汰策略，通常随机过期要比LRU过期淘汰数据更快；

* 使用连接池访问Redis，并配置合理的连接池参数，避免短连接，TCP三次握手和四次挥手的耗时也很高；

* 只使用db0，不推荐使用多个db，使用多个db会增加Redis的负担，每次访问不同的db都需要执行SELECT命令，如果业务线不同，建议拆分多个实例，还能提高单个实例的性能；

* 读的请求量很大时，推荐使用读写分离，前提是可以容忍从节数据更新不及时的问题；

* 写请求量很大时，推荐使用集群，部署多个实例分摊写压力

  

  ## 运维层次有哪些常用的优化建议

* 不同业务线部署不同的实例，各自独立，避免混用，推荐不同业务线使用不同的机器，根据业务重要程度划分不同的分组来部署，避免某一个业务线出现问题影响其他业务线；
* 保证机器有足够的CPU、内存、带宽、磁盘资源，防止负载过高影响Redis性能；
* 以master-slave集群方式部署实例，并分布在不同机器上，避免单点，slave必须设置为readonly；
master和slave节点所在机器，各自独立，不要交叉部署实例，通常备份工作会在slave上做，做备份时会消耗机器资源，交叉部署会影响到master的性能；
* 推荐部署哨兵节点增加可用性，节点数量至少3个，并分布在不同机器上，实现故障自动故障转移；
* 提前做好容量规划，一台机器部署实例的内存上限，最好是机器内存的一半，主从全量同步时会占用最多额外一倍的内存空间，防止网络大面积故障引发所有master-slave的全量同步导致机器内存被吃光；
* 做好机器的CPU、内存、带宽、磁盘监控，在资源不足时及时报警处理，Redis使用Swap后性能急剧下降，网络带宽负载过高访问延迟明显增大，磁盘IO过高时开启AOF会拖慢Redis的性能；
* 设置最大连接数上限，防止过多的客户端连接导致服务负载过高；
* 单个实例的使用内存建议控制在10G以下，过大的实例会导致备份时间久、资源消耗多，主从全量同步数据时间阻塞时间更长；
* 设置合理的slowlog阈值，推荐10毫秒，并对其进行监控，产生过多的慢日志需要及时报警；
* 设置合理的复制缓冲区repl-backlog大小，适当调大repl-backlog可以降低主从全量复制的概率；
* 设置合理的slave节点client-output-buffer-limit大小，对于写入量很大的实例，适当调大可以避免主从复制中断问题；
* 备份时推荐在slave节点上做，不影响master性能；
* 不开启AOF或开启AOF配置为每秒刷盘，避免磁盘IO消耗降低Redis性能；
* 当实例设置了内存上限，需要调大内存上限时，先调整slave再调整master，否则会导致主从节点数据不一致；
* 对Redis增加监控，监控采集info信息时，使用长连接，频繁的短连接也会影响Redis性能；
* 线上扫描整个实例数时，记得设置休眠时间，避免扫描时QPS突增对Redis产生性能抖动；
* 做好Redis的运行时监控，尤其是expired_keys、evicted_keys、latest_fork_usec指标，短时间内这些指标值突增可能会阻塞整个实例，引发性能问题