<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>MySQL事务隔离级别实验 -</title><meta name=keywords content="zyg,独立,博客,程序员,个人,思考,读书,笔记,技术,分享,java"><meta property="og:title" content="MySQL事务隔离级别实验"><meta property="og:site_name" content><meta property="og:image" content="/img/author.jpg"><meta name=title content="MySQL事务隔离级别实验 -"><meta name=description content="zyg | 博客 | 软件 |  Java"><link rel="shortcut icon" href=https://1162492411.github.io/docs/img/favicon.ico><link rel=apple-touch-icon href=https://1162492411.github.io/docs/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://1162492411.github.io/docs/img/apple-touch-icon.png><link href="https://1162492411.github.io/docs/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet type=text/css><link href="https://1162492411.github.io/docs/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel=stylesheet type=text/css><link href=https://1162492411.github.io/docs/css/main.css rel=stylesheet type=text/css><link href=https://1162492411.github.io/docs/css/syntax.css rel=stylesheet type=text/css><script type=text/javascript id=hexo.configuration>var NexT=window.NexT||{};var CONFIG={scheme:'Pisces',sidebar:{"position":"left","display":"post"},fancybox:true,motion:true};</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class="site-meta custom-logo"><div class=custom-logo-site-title><a href=https://1162492411.github.io/docs/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title></span><span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>人生天地间，忽如远行客</p></div><div class=site-nav-toggle><button>
<span class=btn-bar></span><span class=btn-bar></span><span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=https://1162492411.github.io/docs/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E6%8A%80%E6%9C%AF/ rel=section><i class="menu-item-icon fa fa-fw fa-code"></i><br>技术</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E5%AE%9E%E6%88%98/ rel=section><i class="menu-item-icon fa fa-fw fa-code"></i><br>实战</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E7%AC%94%E8%AE%B0/ rel=section><i class="menu-item-icon fa fa-fw fa-book"></i><br>笔记</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/ rel=section><i class="menu-item-icon fa fa-fw fa-leaf"></i><br>面试题</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/post/ rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/about/ rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br></a></li></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span><input type=text id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://1162492411.github.io/docs/post/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E9%AA%8C/ itemprop=url>MySQL事务隔离级别实验</a></h1><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span><span class=post-meta-item-text></span><time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2021-04-01">2021-04-01</time></span>
<span>&nbsp; | &nbsp;
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=post-meta-item-text></span><span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><h1 id=实验环境>实验环境</h1><ul><li><p>MySQL v5.7 docker Mac</p></li><li><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- 建表
</span><span style=color:#75715e></span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> t2
(
    id      int         <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>primary</span> <span style=color:#66d9ef>key</span>,
    content varchar(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>null</span>,
    <span style=color:#66d9ef>type</span>    int         <span style=color:#66d9ef>null</span>
);
<span style=color:#75715e>-- 初始化数据
</span><span style=color:#75715e></span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t2 (id, content,<span style=color:#66d9ef>type</span>) <span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#39;内容1&#39;</span>,<span style=color:#ae81ff>1</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t2 (id, content,<span style=color:#66d9ef>type</span>) <span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#39;内容2&#39;</span>,<span style=color:#ae81ff>2</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t2 (id, content,<span style=color:#66d9ef>type</span>) <span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>4</span>,<span style=color:#e6db74>&#39;内容4&#39;</span>,<span style=color:#ae81ff>4</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t2 (id, content,<span style=color:#66d9ef>type</span>) <span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>6</span>,<span style=color:#e6db74>&#39;内容6&#39;</span>,<span style=color:#ae81ff>6</span>);
</code></pre></div></li></ul><h1 id=理论铺垫>理论铺垫</h1><h2 id=事务定义>事务定义</h2><h2 id=事务的并发问题>事务的并发问题</h2><p>1）脏读</p><p>一个事务读到了另一个未提交事务修改过的数据</p><p>2）不可重复读</p><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</p><p>3）幻读</p><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</p><h2 id=事务的隔离级别>事务的隔离级别</h2><h2 id=事务的创建提交回滚>事务的创建/提交/回滚</h2><h2 id=事务的查看>事务的查看</h2><p>执行命令</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- 需要用户具有process权限
</span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> information_schema.INNODB_TRX
</code></pre></div><p>执行后会出现如下的结果</p><p><img src=https://gitee.com/1162492411/pic/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png alt=image-20210401171514608></p><p>对于结果中各项属性的作用解释如下</p><pre><code>trx_id：唯一事务id号，只读事务和非锁事务是不会创建id的。
TRX_WEIGHT：事务的高度，代表修改的行数（不一定准确）和被事务锁住的行数。为了解决死锁，innodb会选择一个高度最小的事务来当做牺牲品进行回滚。已经被更改的非交易型表的事务权重比其他事务高，即使改变的行和锁住的行比其他事务低。
TRX_STATE：事务的执行状态，值一般分为：RUNNING, LOCK WAIT, ROLLING BACK, and COMMITTING.
TRX_STARTED：事务的开始时间
TRX_REQUESTED_LOCK_ID:如果trx_state是lockwait,显示事务当前等待锁的id，不是则为空。想要获取锁的信息，根据该lock_id，以innodb_locks表中lock_id列匹配条件进行查询，获取相关信息。
TRX_WAIT_STARTED：如果trx_state是lockwait,该值代表事务开始等待锁的时间；否则为空。
TRX_MYSQL_THREAD_ID：mysql线程id。想要获取该线程的信息，根据该thread_id，以INFORMATION_SCHEMA.PROCESSLIST表的id列为匹配条件进行查询。
TRX_QUERY：事务正在执行的sql语句。
TRX_OPERATION_STATE：事务当前的操作状态，没有则为空。
TRX_TABLES_IN_USE：事务在处理当前sql语句使用innodb引擎表的数量。
TRX_TABLES_LOCKED：当前sql语句有行锁的innodb表的数量。（因为只是行锁，不是表锁，表仍然可以被多个事务读和写）
TRX_LOCK_STRUCTS：事务保留锁的数量。
TRX_LOCK_MEMORY_BYTES：在内存中事务索结构占得空间大小。
TRX_ROWS_LOCKED：事务行锁最准确的数量。这个值可能包括对于事务在物理上存在，实际不可见的删除标记的行。
TRX_ROWS_MODIFIED：事务修改和插入的行数
TRX_CONCURRENCY_TICKETS：该值代表当前事务在被清掉之前可以多少工作，由 innodb_concurrency_tickets系统变量值指定。
TRX_ISOLATION_LEVEL：事务隔离等级。
TRX_UNIQUE_CHECKS：当前事务唯一性检查启用还是禁用。当批量数据导入时，这个参数是关闭的。
TRX_FOREIGN_KEY_CHECKS：当前事务的外键坚持是启用还是禁用。当批量数据导入时，这个参数是关闭的。
TRX_LAST_FOREIGN_KEY_ERROR：最新一个外键错误信息，没有则为空。
TRX_ADAPTIVE_HASH_LATCHED：自适应哈希索引是否被当前事务阻塞。当自适应哈希索引查找系统分区，一个单独的事务不会阻塞全部的自适应hash索引。自适应hash索引分区通过 innodb_adaptive_hash_index_parts参数控制，默认值为8。
TRX_ADAPTIVE_HASH_TIMEOUT：是否为了自适应hash索引立即放弃查询锁，或者通过调用mysql函数保留它。当没有自适应hash索引冲突，该值为0并且语句保持锁直到结束。在冲突过程中，该值被计数为0，每句查询完之后立即释放门闩。当自适应hash索引查询系统被分区（由 innodb_adaptive_hash_index_parts参数控制），值保持为0。
TRX_IS_READ_ONLY：值为1表示事务是read only。
TRX_AUTOCOMMIT_NON_LOCKING：值为1表示事务是一个select语句，该语句没有使用for update或者shared mode锁，并且执行开启了autocommit，因此事务只包含一个语句。当TRX_AUTOCOMMIT_NON_LOCKING和TRX_IS_READ_ONLY同时为1，innodb通过降低事务开销和改变表数据库来优化事务。
</code></pre><p>也可以直接参考<a href=https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-trx-table.html>官方链接</a></p><h2 id=快照读和当前读>快照读和当前读</h2><h2 id=隔离级别能解决哪些并发问题>隔离级别能解决哪些并发问题</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>RU</td><td>√</td><td>√</td><td>√</td></tr><tr><td>RC</td><td>×</td><td>√</td><td>√</td></tr><tr><td>RR</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h1 id=并发问题验证>并发问题验证</h1><h2 id=ru实验>RU实验</h2><h3 id=实验一--验证ru下的脏读问题>实验一 ： 验证RU下的脏读问题</h3><ul><li>事务A ：Autocommit = 0，Isolation = RU</li><li>事务B ：Autocommit = 0，Isolation = RU</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T2</td><td></td><td></td><td>update t2 set type=2222 where id=1;</td><td></td><td></td></tr><tr><td>T3</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T4</td><td>select * from t2 where id=1 ;</td><td>type的值为2222</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T2时刻，事务B修改了数据但没有提交事务</li><li>T4时刻，事务A查询到了事务B未提交的修改，发生了脏读</li></ul><h3 id=实验二--验证ru下的不可重复读问题>实验二 ： 验证RU下的不可重复读问题</h3><ul><li>事务A ：Autocommit = 0，Isolation = RU</li><li>事务B ：Autocommit = 0，Isolation = RU</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where id=1 ;</td><td>type的值为1</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>update t2 set type=2222 where id=1;</td><td></td><td></td></tr><tr><td>T5</td><td>select * from t2 where id=1 ;</td><td>type的值为2222</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T1时刻，事务A正常读取到type的值为1</li><li>T4时刻，事务B将type的值修改为2222但并没有提交</li><li>T5时刻，事务A读取type的值为2222，与T1时刻相比，同一个事务中两次读取的值不同</li></ul><h3 id=实验三--验证ru下的幻读问题>实验三 ： 验证RU下的幻读问题</h3><ul><li>事务A ：Autocommit = 0，Isolation = RU</li><li>事务B ：Autocommit = 0，Isolation = RU</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where type between 1 and 3;</td><td>数据1数据2</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>insert into t2 (id, content, type) value (11,&lsquo;ccc&rsquo;,2);</td><td></td><td></td></tr><tr><td>T5</td><td>select * from t2 where type between 1 and 3;</td><td>数据1数据2数据11</td><td></td><td></td><td></td></tr><tr><td>T6</td><td></td><td></td><td>rollback</td><td></td><td></td></tr><tr><td>T7</td><td>select * from t2 where type between 1 and 3;</td><td>数据1数据2</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T4时刻事务B插入了数据11但是并没有提交事务</li><li>T5时刻事务A查询到了数据11</li><li>T6时刻事务B回滚了事务</li><li>T7时刻事务A又查不到数据11，与T5时刻相比，数据11消失不见了</li><li>(也可以拿T1～T5时刻进行比较，T5时刻的结果相比T2时刻竟然多了数据11这条记录)</li></ul><h2 id=rc实验>RC实验</h2><h3 id=实验一--验证rc下的脏读问题不存在>实验一 ： 验证RC下的脏读问题（不存在）</h3><ul><li>事务A ：Autocommit = 0，Isolation = RC</li><li>事务B ：Autocommit = 0，Isolation = RC</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T2</td><td></td><td></td><td>update t2 set type=2222 where id=1;</td><td></td><td></td></tr><tr><td>T3</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T4</td><td>select * from t2 where id=1 ;</td><td>type的值为1</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T2时刻，事务B修改了数据但没有提交事务</li><li>T4时刻，事务A读取数据，type为1，并没有受到事务B修改为2222的影响</li></ul><h3 id=实验二-验证rc下的不可重复读问题>实验二 ：验证RC下的不可重复读问题</h3><ul><li>事务A ：Autocommit = 0，Isolation = RC</li><li>事务B ：Autocommit = 0，Isolation = RC</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where id=1 ;</td><td>type的值为1</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>update t2 set type=2222 where id=1;</td><td></td><td></td></tr><tr><td>T5</td><td></td><td></td><td>commit</td><td></td><td></td></tr><tr><td>T6</td><td>select * from t2 where id=1 ;</td><td>type的值为2222</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T1时刻，事务A正常读取到type的值为1</li><li>T4时刻，事务B将type的值修改为2222并在T5时刻提交事务</li><li>T6时刻，事务A读取type的值为2222，与T1时刻相比，同一个事务中两次读取的值不同</li></ul><h3 id=实验三--验证rc下的幻读问题>实验三 ： 验证RC下的幻读问题</h3><ul><li>事务A ：Autocommit = 0，Isolation = RC</li><li>事务B ：Autocommit = 0，Isolation = RC</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where type between 1 and 3;</td><td>数据1数据2</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>insert into t2 (id, content, type) value (11,&lsquo;ccc&rsquo;,2);</td><td></td><td></td></tr><tr><td>T5</td><td></td><td></td><td>commit</td><td></td><td></td></tr><tr><td>T6</td><td>select * from t2 where type between 1 and 3;</td><td>数据1数据2数据11</td><td></td><td></td><td></td></tr></tbody></table><p>分析 ：</p><ul><li>T2时刻事务A可以看到两条数据</li><li>T3～T5时刻事务B插入了数据11并提交事务</li><li>T6时刻，事务A看到了三条数据，相比T2时刻多了一条数据</li></ul><h2 id=rr实验>RR实验</h2><h3 id=实验一-验证rr下的脏读问题不存在>实验一 ：验证RR下的脏读问题(不存在)</h3><ul><li>事务A ：Autocommit = 0，Isolation = RR</li><li>事务B ：Autocommit = 0，Isolation = RR</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T2</td><td></td><td></td><td>update t2 set type=2222 where id=1;</td><td></td><td></td></tr><tr><td>T3</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T4</td><td>select * from t2 where id=1 ;</td><td>type的值为1</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T2时刻，事务B修改了数据但没有提交事务</li><li>T4时刻，事务A读取数据，type为1，并没有受到事务B修改为2222的影响</li></ul><h3 id=实验二-验证rr下的不可重复读问题不存在>实验二 ：验证RR下的不可重复读问题(不存在)</h3><ul><li>事务A ：Autocommit = 0，Isolation = RR</li><li>事务B ：Autocommit = 0，Isolation = RR</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where id=1 ;</td><td>type的值为1</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>update t2 set type=2222 where id=1;</td><td></td><td></td></tr><tr><td>T5</td><td></td><td></td><td>commit</td><td></td><td></td></tr><tr><td>T6</td><td>select * from t2 where id=1 ;</td><td>type的值为1</td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T1时刻，事务A正常读取到type的值为1</li><li>T4时刻，事务B将type的值修改为2222并在T5时刻提交事务</li><li>T6时刻，事务A读取type的值为1，与T1时刻相比，同一个事务中两次读取的值相同</li></ul><h3 id=实验三-验证rr下的幻读问题>实验三 ：验证RR下的幻读问题</h3><ul><li>事务A ：Autocommit = 0，Isolation = RR</li><li>事务B ：Autocommit = 0，Isolation = RR</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where type between 1 and 3;</td><td>数据1数据2</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>SQL1 : insert into t2 (id, content, type) value (11,&lsquo;ccc&rsquo;,2);SQL2 : update t2 set type=2 where id=4;</td><td></td><td>执行SQL1/SQL2均可</td></tr><tr><td>T5</td><td></td><td></td><td>commit</td><td></td><td></td></tr><tr><td>T6</td><td>select * from t2 where type between 1 and 3 for update;</td><td>数据1数据2数据11/数据4</td><td></td><td></td><td></td></tr></tbody></table><p>分析 ：</p><ul><li>T2时刻事务A可以看到两条数据</li><li>T3～T5时刻事务B插入了数据11/修改了数据4并提交事务</li><li>T6时刻，事务A看到了三条数据，相比T2时刻多了一条数据</li></ul><h2 id=序列化实验>序列化实验</h2><h3 id=todo实验一-验证序列化下的脏读问题不存在>Todo实验一 ：验证序列化下的脏读问题(不存在)</h3><h3 id=todo实验二-验证序列化下的不可重复读问题不存在>todo实验二 ：验证序列化下的不可重复读问题(不存在)</h3><h3 id=todo实验三-验证序列化下的幻读问题不存在>todo实验三 ：验证序列化下的幻读问题(不存在)</h3><h1 id=实验>实验</h1><h2 id=实验一-验证当前读和快照读>实验一 ：验证当前读和快照读</h2><ul><li>事务A ：Autocommit = 0，Isolation = RR</li><li>事务B ：Autocommit = 0，Isolation = RR</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>Begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where type between 5 and 10;</td><td>6,文字6,6</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>insert into t2 (id, content,type) values (7,&lsquo;内容7&rsquo;,7);</td><td></td><td></td></tr><tr><td>T5</td><td>select * from t2 where type between 5 and 10;</td><td>6,文字6,6</td><td></td><td></td><td></td></tr><tr><td>T6</td><td></td><td></td><td>commit</td><td></td><td></td></tr><tr><td>T7</td><td>select * from t2 where type between 5 and 10;</td><td>6,文字6,6</td><td></td><td></td><td></td></tr><tr><td>T8</td><td>select * from t2 where type between 5 and 10 for update;</td><td>6,文字6,67,内容7,7</td><td></td><td></td><td></td></tr><tr><td>T9</td><td>commit</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T5时刻执行了查询语句，但是事务A并没有看到数据7，因为事务B此时没有提交事务</li><li>T7时刻执行了查询语句，事务B已经提交事务，事务A仍然没有看到数据7，在T8时刻才能看到数据7，因为select是快照读，而select for update是当前读</li></ul><h2 id=实验二--select-for-update排它锁的验证>实验二 ： select for update排它锁的验证</h2><ul><li>事务A ：Autocommit = 0，Isolation = RR</li><li>事务B ：Autocommit = 0，Isolation = RR</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>Begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>select * from t2 where type between 5 and 10;</td><td>数据6</td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>insert into t2 (id, content,type) values (7,&lsquo;内容7&rsquo;,7);</td><td></td><td></td></tr><tr><td>T5</td><td>SQL1 ： select * from t2 where type between 5 and 10 for update ;SQL2 ：select * from t2 where type = 2 for update ;SQL3 ：select * from t2 where type between 5 and 10;SQL4 ：select * from t2 where type = 2</td><td>若执行SQL1会阻塞直到超时；若type字段无索引，执行SQL2会阻塞，若type字段又索引，执行SQL会查询出数据2；若执行SQL3会查询出数据6;若执行SQL4会查询出数据2</td><td>SQL5 : select * from t2 where type = 2 for update ;SQL6 : select * from t2 where id = 2 for update ;</td><td></td><td></td></tr><tr><td>T6</td><td></td><td></td><td>Commit</td><td></td><td></td></tr><tr><td>T7</td><td>select * from t2 where type between 5 and 10 ;</td><td>数据6</td><td></td><td></td><td></td></tr><tr><td>T8</td><td>select * from t2 where type between 5 and 10 for update;</td><td>数据6数据7</td><td></td><td></td><td></td></tr><tr><td>T9</td><td>commit</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T5时刻，四条SQL中，若执行SQL1会阻塞，因为此刻事务B正在插入数据，若执行SQL3/SQL4不会阻塞，因为这两条SQL是当前读；若type字段无索引时，执行SQL1/SQL2时会锁表，无法修改表的数据但可以快照读，若type字段有索引并且命中索引时，执行SQL1/SQL2时仅会锁住范围内的数据(关于行锁和表锁以及与索引的实际情况比较复杂)</li><li>T7时刻，执行SQL无法查询出数据7，因为select是当前读，事务A开始时就看不到数据7，此刻也应该看不到数据7</li><li>T8时刻，执行SQL可以查询出数据7，因为此刻没有其他事务在修改/插入数据，所以不会阻塞，因为select for update是当前读，因此可以看到数据7</li></ul><h2 id=实验三--验证排它锁的行锁和表锁todo>实验三 ： 验证排它锁的行锁和表锁(todo)</h2><h2 id=实验四-验证两个写事务>实验四 ：验证两个写事务</h2><ul><li>事务A ：Autocommit = 0，Isolation = RR</li><li>事务B ：Autocommit = 0，Isolation = RR</li></ul><table><thead><tr><th>时间</th><th>事务A</th><th>事务A结果</th><th>事务B</th><th>事务B结果</th><th>备注</th></tr></thead><tbody><tr><td>T1</td><td>Begin</td><td></td><td></td><td></td><td></td></tr><tr><td>T2</td><td>insert into t2 (id, content,type) values (9,&lsquo;内容9&rsquo;,9);</td><td></td><td></td><td></td><td></td></tr><tr><td>T3</td><td></td><td></td><td>begin</td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>SQL1 : insert into t2 (id, content,type) values (7,&lsquo;内容7&rsquo;,7);SQL2 : insert into t2 (id, content,type) values (9,&lsquo;内容7&rsquo;,9);</td><td></td><td></td></tr><tr><td>T5</td><td>commit</td><td></td><td></td><td></td><td></td></tr><tr><td>T6</td><td></td><td></td><td>commit</td><td></td><td></td></tr></tbody></table><p>分析：</p><ul><li>T4时刻，执行SQL1，可以正常执行，并且T5、T6可以正常提交</li><li>T4时刻，执行SQL2，事务B阻塞等待，T5时刻事务A提交后，事务B会报错主键冲突</li></ul><h2 id=实验五-select-常量-for-update>实验五 ：select 常量 for update</h2><p>例如 select &lsquo;xx&rsquo; for update，在这种场景中，即便手动begin事务，仍然不会在mysql的事务列表中观察到事务</p><h2 id=需要继续研究--意向锁意向锁之间的兼容情况select-for-update和select-in-share-mode之间的异同点>需要继续研究 ： 意向锁、意向锁之间的兼容情况、select for update和select in share mode之间的异同点</h2></div><footer class=post-footer><div class=post-tags><a href=https://1162492411.github.io/docs/tags/%e6%95%b0%e6%8d%ae%e5%ba%93 rel=tag title=数据库>#数据库#</a>
<a href=https://1162492411.github.io/docs/tags/%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab rel=tag title=隔离级别>#隔离级别#</a>
<a href=https://1162492411.github.io/docs/tags/mysql rel=tag title=MySQL>#MySQL#</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://1162492411.github.io/docs/post/github%E7%AB%99%E7%82%B9443%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/ rel=next title=Github站点443超时问题解决><i class="fa fa-chevron-left"></i>Github站点443超时问题解决</a></div><div class="post-nav-prev post-nav-item"><a href=https://1162492411.github.io/docs/post/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/ rel=prev title=版本控制常见面试题>版本控制常见面试题 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=https://1162492411.github.io/docs/img/author.jpg alt=zyg><p class=site-author-name itemprop=name>zyg</p><p class="site-description motion-element" itemprop=description>Programmer & Architect</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=https://1162492411.github.io/docs/post/><span class=site-state-item-count>28</span>
<span class=site-state-item-name></span></a></div><div class="site-state-item site-state-categories"><a href=https://1162492411.github.io/docs/categories/><span class=site-state-item-count>27</span>
<span class=site-state-item-name></span></a></div><div class="site-state-item site-state-tags"><a href=https://1162492411.github.io/docs/tags/><span class=site-state-item-count>47</span>
<span class=site-state-item-name></span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/1162492411/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="links-of-blogroll motion-element inline"><script type=text/javascript src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&m=0&s=220&c=ff0000&cr1=ffffff&f=arial&l=33&bv=35" async></script></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span itemprop=copyrightYear>&copy;
2009 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=author itemprop=copyrightHolder></span></div><div class=powered-by>Powered by - <a class=theme-link href=http://gohugo.io target=_blank title=hugo>Hugo v0.68.3</a></div><div class=theme-info>Theme by - <a class=theme-link href=https://github.com/xtfly/hugo-theme-next target=_blank>NexT</a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript>if(Object.prototype.toString.call(window.Promise)!=='[object Function]'){window.Promise=null;}</script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/jquery/index.js?v=2.1.3"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/velocity/velocity.min.js?v=1.2.1"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="https://1162492411.github.io/docs/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="https://1162492411.github.io/docs/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script><script type=text/javascript src=https://1162492411.github.io/docs/js/utils.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/motion.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/affix.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/schemes/pisces.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/scrollspy.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/post-details.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/toc.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/bootstrap.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/search.js></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>