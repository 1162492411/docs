<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Redis常见面试题 -</title><meta name=keywords content="zyg,独立,博客,程序员,个人,思考,读书,笔记,技术,分享,java"><meta property="og:title" content="Redis常见面试题"><meta property="og:site_name" content><meta property="og:image" content="/img/author.jpg"><meta name=title content="Redis常见面试题 -"><meta name=description content="zyg | 博客 | 软件 |  Java"><link rel="shortcut icon" href=https://1162492411.github.io/docs/img/favicon.ico><link rel=apple-touch-icon href=https://1162492411.github.io/docs/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://1162492411.github.io/docs/img/apple-touch-icon.png><link href="https://1162492411.github.io/docs/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet type=text/css><link href="https://1162492411.github.io/docs/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel=stylesheet type=text/css><link href=https://1162492411.github.io/docs/css/main.css rel=stylesheet type=text/css><link href=https://1162492411.github.io/docs/css/syntax.css rel=stylesheet type=text/css><script type=text/javascript id=hexo.configuration>var NexT=window.NexT||{};var CONFIG={scheme:'Pisces',sidebar:{"position":"left","display":"post"},fancybox:true,motion:true};</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class="site-meta custom-logo"><div class=custom-logo-site-title><a href=https://1162492411.github.io/docs/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title></span><span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>人生天地间，忽如远行客</p></div><div class=site-nav-toggle><button>
<span class=btn-bar></span><span class=btn-bar></span><span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=https://1162492411.github.io/docs/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E6%8A%80%E6%9C%AF/ rel=section><i class="menu-item-icon fa fa-fw fa-code"></i><br>技术</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E5%AE%9E%E6%88%98/ rel=section><i class="menu-item-icon fa fa-fw fa-code"></i><br>实战</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E7%AC%94%E8%AE%B0/ rel=section><i class="menu-item-icon fa fa-fw fa-book"></i><br>笔记</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/ rel=section><i class="menu-item-icon fa fa-fw fa-leaf"></i><br>面试题</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/post/ rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=https://1162492411.github.io/docs/about/ rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br></a></li></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span><input type=text id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://1162492411.github.io/docs/post/redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/ itemprop=url>Redis常见面试题</a></h1><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span><span class=post-meta-item-text></span><time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2020-12-22">2020-12-22</time></span>
<span class=post-category>&nbsp; | &nbsp;
<span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span><span class=post-meta-item-text></span><span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=https://1162492411.github.io/docs/categories/redis itemprop=url rel=index><span itemprop=name>Redis</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=https://1162492411.github.io/docs/categories/nosql itemprop=url rel=index><span itemprop=name>NoSQL</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=https://1162492411.github.io/docs/categories/%E6%95%B0%E6%8D%AE%E5%BA%93 itemprop=url rel=index><span itemprop=name>数据库</span></a>
&nbsp;</span></span>
<span>&nbsp; | &nbsp;
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=post-meta-item-text></span><span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><h1 id=原理篇>原理篇</h1><h2 id=如何理解redis的通讯协议resp协议>如何理解Redis的通讯协议resp协议</h2><span class=spoiler>为了服务端和客户端轻量化通信而设计的简单协议</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=为什么早期版本redis是单线程的>为什么早期版本Redis是单线程的</h2><span class=spoiler>Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis为什么速度快>Redis为什么速度快</h2><span class=spoiler>1）绝大部分操作为基于内存的操作
2）数据结构和对数据的操作简单
3）采用单线程减少上下文切换和竞争，不需要考虑锁的问题
4）使用多路I/O复用模型，非阻塞IO，多个网络连接使用同一个线程
5）通过队列将访问串形化，减少传统关系型数据的串行控制开销</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis如何划分内存>Redis如何划分内存</h2><span class=spoiler>1）used_memory ：Redis分配器分配的内存总量；
2）used_memory_rss ：进程占据操作系统的内存；
3）mem_fragmentation_ratio ： 内存碎片率，used_memory_rss / used_memory；
4）mem_allocator ： 使用的内存分配器</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis事务的cas>Redis事务的CAS</h2><span class=spoiler></span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的文件事件处理器都包含哪些部分>redis的文件事件处理器都包含哪些部分</h2><span class=spoiler>1）多个 socket用来完成请求的接收与响应信息的发送
2）IO 多路复用程序
3）文件事件分派器用来协调调度
4）事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）用来真正干活</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h1 id=基础篇>基础篇</h1><h2 id=redis都有哪些基础的数据结构他们各自的底层是如何实现的对应的使用场景是什么>Redis都有哪些基础的数据结构，他们各自的底层是如何实现的，对应的使用场景是什么</h2><span class=spoiler>1）String ： 类似Java的动态数组，在内部预先分配一定空间，场景为存储键值对；
2）Hash ： 类似Java的HashMap，数据+链表结构，发生 hash 碰撞时将会把元素追加到链表上，场景为存储购物车信息或者对象；
3）List ： 类似Java的LinkedList，插入与删除数据的复杂度为O(1),数据量少时为一块内存连续的ziplist，数据量多时采用有前后指针的quicklist，redis3.2以后是ziplist+quicklist，场景为点赞列表、评论列表；
4）Set ： 类似Java的HashSet，键无序且唯一，value为null，场景为好友、关注、粉丝、感兴趣的人集合；
5）SortedSet ：有序集合，内部实现为ziplist或者skiplist，场景为排行榜</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis有哪些高级的数据结构对应的使用场景是什么>Redis有哪些高级的数据结构，对应的使用场景是什么</h2><span class=spoiler>1)BitMaps : 位图,面向bit进行操作,每个bit位为一个值,极度节省空间,经典使用场景是用户的每日签到记录
2)HyperLogLog : 基数统计,基数是数据集去重后元素个数,经典使用场景是统计用户UV
3)GEO : 处理地理位置</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis如何做到数据持久化这些方式各自有什么优缺点>Redis如何做到数据持久化，这些方式各自有什么优缺点</h2><span class=spoiler>RDB保存快照，AOF保存执行命令的记录并合并命令；
1) RDB有两种方式：同步save模式和异步bgsave模式，同步save模式可以保证数据一致性；
save会导致redis阻塞，bgsave在大数据量时fork会引起抖动，导致短暂时间内redis响应变慢，且fork需要一定的内存开销；
rdb文件默认每次rdb时进行替换并压缩；
rdb优点：文件紧凑，体积小，适合全量备份与复制，且加载rdb文件的速度比加载aof文件的速度快
rdb缺点：无法秒级别持久化，老版本redis无法兼容新版本的rdb
2) aof是目前主流的持久数据的方式，aof每次都会将写命令保存到缓冲区然后追加输出到aof文件中，</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis慢查询如何开启>Redis慢查询如何开启</h2><span class=spoiler>设置slowlog-log-slower-than属性来配置慢查询时间的阈值，设置slowlog-max-len属性来配置存储多少条慢查询命令</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的默认内存为多大>Redis的默认内存为多大</h2><span class=spoiler>32位机器默认3个G，64位机器默认不限制</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的淘汰策略有哪些>Redis的淘汰策略有哪些</h2><span class=spoiler>1）noeviction ： 不删除
2）allkeys-lru ： 从所有key中删除最近最少使用的key
3）volatile-lru ： 从设置了过期时间的key中删除最近最少使用的key
4）allkeys-random ： 从所有key中随机删除
5）volatile-random ： 从设置了过期时间的key中随机删除
6）volatile-ttl ： 从设置了过期时间的key中删除剩余时间最短的
7）allkeys-lfu ：淘汰访问频率最低的key
8）volatile-lfu ：只淘汰访问频率最低的过期key</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的删除策略有哪些这些删除策略各自有什么优缺点>Redis的删除策略有哪些，这些删除策略各自有什么优缺点</h2><span class=spoiler>1）定时删除 ： 在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作，优点是对内存友好可以即时释放，缺点是对cpu不友好可能大量key同时删除；
2）定期删除 ： 每隔一定时间删除过期的键，优点是对cpu友好，缺点是对内存不友好；
3）惰性删除 ： 放任键过期不管，但在每次获取键时，判断是否过期，若过期再删除，优点是对cpu友好，缺点是对内存不友好</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的pipeline如何理解>Redis的Pipeline如何理解</h2><span class=spoiler>将多个命令一次性发送并执行，节省网络消耗，虽然命令执行时可能被其他命令穿插</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis如何设置过期时间>Redis如何设置过期时间</h2><span class=spoiler>1）expire key milliseconds在指定毫秒后过期；
2）expire key seconds在指定秒后过期；
3）expire at key timestamp 在指定的时间戳（秒级别）后过期；
4）expire at key millisecondsTimestamp 在指定的时间戳（毫秒）后过期</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis支持哪些集群模式>Redis支持哪些集群模式</h2><span class=spoiler>1）主从复制模式；2）Sentinel哨兵模式；3）cluster模式</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的事务是否支持回滚>Redis的事务是否支持回滚</h2><h2 id=redis的事务有哪些相关命令>Redis的事务有哪些相关命令</h2><h2 id=redis有哪些常用的缓存更新策略>Redis有哪些常用的缓存更新策略</h2><h1 id=扩容篇>扩容篇</h1><h2 id=string如何扩容>String如何扩容</h2><span class=spoiler>增加空间时 ：小于1m时每次加倍扩容+1，大于1m时每次增加1m+1，最大为512m
释放空间时：惰性释放，当底层buf数组的实际使用小于数组容量时候不马上缩容。</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=hash如何扩容>Hash如何扩容</h2><span class=spoiler>1）申请旧hash两倍的内存空间，使得原有的字典同时持有旧hash表和新hash表
2）维护一个标志变量rehashindex用于记录进度
3）访问字典时将旧hash表中位于rehashindex这个桶中的key全部转移到新hash表中
4）全部转移完时修改记录进度rehashindex</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=list如何扩容>List如何扩容</h2><span class=spoiler>1）老版本的redis中list有两种数据结构 ： ziplist和linkedlist。首先以ziplist进行存储，在不满足ziplist的存储要求后转换为linkedlist列表
ziplist是为了节省内存而开辟的一连串连续空间，linkedlist则是以节点为单位的无环双向链表
当不满足以下条件时会将ziplist转换为linkedlist
- 列表对象保存的所有字符串元素的长度小于64字节
- 列表对象保存的元素数量小于512个
2）后来redis3.2进一步引入了quicklist，以ziplist为单位，将多个ziplist作为链表的节点串起来</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h1 id=实战篇>实战篇</h1><h2 id=redis有哪些常用场景>Redis有哪些常用场景</h2><span class=spoiler>1）缓存
2）Session共享
3）简单的消息队列</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=如何理解缓存穿透缓存击穿缓存雪崩如何解决>如何理解缓存穿透、缓存击穿、缓存雪崩，如何解决</h2><span class=spoiler>1）缓存穿透 ： 查询一个redis中不可能存在的值，比如空值或者特殊的值，解决方案：
* 将一些不存在的值也放入redis中；
* 采用布隆过滤器；
2）缓存击穿 ：说单个key非常热点，当这个key在失效的瞬间，大量的请求直接请求数据库，解决方案：
* 热点数据设置为永远不过期，缺点是内存消耗大，并且不能保持数据最新
* java层面的互斥 ：**通过synchronized+双重检查机制：某个key只让一个线程查询，阻塞其它线**程，在同步块中，继续判断检查，保证不存在，才去查DB。缺点是会阻塞其他线程
* redis层面的互斥 ：在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用set NX去set一个mutex key(最好加上失效时间避免待会儿删除mutex key失败)，当操作返回成功时，再进行load db的操作并回设缓存并删除mutex key；否则，就重试整个get缓存的方法。缺点是代码更复杂，存在死锁风险，删除mutex key失败时短期内这些key查不到数据
3）缓存雪崩 ： 大批量的缓存集中在某个时刻失效，解决方案：
* 设置过期时间不一致
* 加锁排队
* 建立备份缓存
* 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 - 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。 - 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据；</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis内存使用满会出现什么现象>Redis内存使用满会出现什么现象</h2><span class=spoiler>无法写入只能读取</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis如何实现定时队列>Redis如何实现定时队列</h2><span class=spoiler></span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis如何实现消息队列>Redis如何实现消息队列</h2><span class=spoiler>1）基于List的 LPUSH+BRPOP 的实现，使用rpush和lpush操作入队列，lpop和rpop操作出队列，引入阻塞读blpop和brpop，阻塞读在队列没有数据的时候进入休眠状态，一旦数据到来则立刻醒过来，消息延迟几乎为零，这种方案当一直没有消息时会导致连接空闲从而被释放，下次使用连接时报错，而且也没有消费者ACK机制，也不能重复消费，也不能进行广播；
2）PUB/SUB，订阅/发布模式，广播模式，消息可以即时发送，但是若消息发布时消费者不在线会丢失小消息，消息积压时也不好处理；
3）基于Sorted Set，消息id自己实现有序递增，缺点是不能存在重复的消息id；
4）基于stream，redis5.0开始支持，借鉴kafka，采用消息链表，消息持久化，可以记录消费者的消费进度，可以确保消息至少被消费一次，但是消息过多时旧消息会丢失，消费者消费消息但不ack会导致pel列表增大而消耗内存</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的并发竞争如何解决>Redis的并发竞争如何解决</h2><span class=spoiler>1）多个实例更新一个key时通过加锁排队让命令串形化</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis和数据库如何实现双写一致性>Redis和数据库如何实现双写一致性</h2><span class=spoiler>1）Cache Aside Pattern ：
* 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先更新数据库，然后再删除缓存，这种方案实际上在高并发的时候可以继续进行优化</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=有哪些基于redis实现的分布式锁>有哪些基于Redis实现的分布式锁</h2><span class=spoiler>1）setnx + expire；
2）setIfAbsent；
3）基于zookeeper的有序节点实现分布式锁；
4）redssion ：采用看门狗，定期续期 ；
5）redlock ： 将加锁命令发送到多个节点参与，如果大多数都加锁成功就成功，如果失败就逐个恢复锁；</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis中的key过期了是否立即释放内存为什么>Redis中的key过期了是否立即释放内存，为什么</h2><span class=spoiler>不是，为了快</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=如何保证redis的高可用和高并发>如何保证Redis的高可用和高并发</h2><span class=spoiler>1）基于一主多从，主节点进行写入，每秒w级别的qps，从节点进行读取，每秒10w级别的qps
2）加上哨兵，当节点出现故障时进行主备切换</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=一致性hash算法是什么>一致性hash算法是什么</h2><span class=spoiler></span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis变慢如何排查>Redis变慢如何排查</h2><span class=spoiler>1）查看慢命令，分析是否存在复杂命令
2）查看是否存在大key
3）查看是否缓存雪崩
4）查看淘汰策略，查看内存是否打满
5）查看fork进程频率是否合理
6）查看内存分配是否合理
7）查看aof追加策略
8）如果是单机部署了多个redis，定位是否存在aof竞争问题
9）查看是否使用swap
10）查看网卡负载是否正常</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=如何为redis一次增加大批量数据>如何为Redis一次增加大批量数据</h2><span class=spoiler>1）管道2）手动拼接发送resp命令</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h1 id=主从模式>主从模式</h1><h2 id=如何配置主从模式>如何配置主从模式</h2><span class=spoiler>* 临时性 ： 直接在客户端执行 slaveof ip port 的方式
* 永久性 ： 通过在配置文件 redis.conf 中设置 slaveof 方式</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=主从结构下数据一致性问题如何解决>主从结构下，数据一致性问题如何解决</h2><span class=spoiler>1）分析业务场景，若允许不一致，则无需处理
2）选择性读主：核心思路是将变动的情况写入在一个cache中，从节点从这个cache中查看是否包含本次的数据。
* 记录变化情况 ：将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”
* 查询时若cache有这个key ： 说明1s内刚发生过写请求，数据库主从同步可能还没有完成，此时就应该去主库查询
* 查询时若cache没有这个key ：说明最近没有发生过写请求，此时就可以去从库查询</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis的主从复制原理是什么>Redis的主从复制原理是什么</h2><span class=spoiler>1）从节点连接主节点，向主节点发起同步请求
2）主节点开始生成rdb文件(如果是首次则全量生成，如果非首次，根据从节点传递的偏移量生成)一边发送rdb文件到从节点，一边将开始生成rdb文件之后到命令放入缓冲区
3）主节点将rdb文件发送到从节点之后，将缓冲区内的命令发送给从节点</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=主从模式下每次新增从节点时主节点均全量复制如何减轻主节点的压力>主从模式下每次新增从节点时主节点均全量复制，如何减轻主节点的压力</h2><span class=spoiler>在旧的从节点中建立级联从节点，这样虽然可能导致部分数据延迟复制到新的从节点，但是可以大幅度减小主节点压力</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h1 id=集群模式>集群模式</h1><h2 id=集群模式下redis节点会开启哪些端口>集群模式下redis节点会开启哪些端口</h2><span class=spoiler>* 6xxx端口 ： 提供正常的读写功能
* 6xxxx + 10000 端口 ： 通过集群总线进行节点间通信，进行故障检测，配置更新，故障转移授权</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=redis集群模式下redis的key如何寻址分布式寻址都有哪些算法>Redis集群模式下，redis的key如何寻址，分布式寻址都有哪些算法</h2><span class=spoiler>寻址算法 ：
1）hash 算法（大量缓存重建）：计算hash后取模，访问不同的节点
2）一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） ：将整个 hash 值空间组织成一个虚拟的圆环
3）redis cluster 的 hash slot 算法 ：对每个 key 计算 CRC16 值，然后对 16384 取模，放入16384个slot中的一个，每个redis节点持有部分slot。增加节点时各节点迁移部分slot给新节点，减少节点时将该节点的slot分发给其他节点</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=如何理解redis的cluster-bus的gossip协议>如何理解Redis的cluster bus的gossip协议</h2><span class=spoiler>1）用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间；
2）gossip 协议包含多种消息，包含 ping、pong、meet、fail 等等；
3）ping ： 每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据；
4）meet ： 某个节点发送 meet 给新加入的节点，让新节点加入集群中；
5）pong ： 返回meet和ping；
6）fail ： 节点停止后发送fail告知其他节点；</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h1 id=一致性hash>一致性hash</h1><h2 id=一致性hash为了解决什么问题>一致性hash为了解决什么问题</h2><span class=spoiler>一致性hash算法主要应用于分布式存储系统中，可以有效地解决分布式存储结构下普通余数Hash算法带来的伸缩性差的问题，可以保证在动态增加和删除节点的情况下尽量有多的请求命中原来的机器节点</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=一致性hash如何解决伸缩性差的问题>一致性hash如何解决伸缩性差的问题</h2><span class=spoiler>将节点ip根据 2的31次方取模，防止在hash环中，这样当节点增加/减少/发生故障时，仅会影响一两个redis节点的数据</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h2 id=一致性hash如何解决数据倾斜问题>一致性hash如何解决数据倾斜问题</h2><span class=spoiler>引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node 1#1”、“Node 1#2”、“Node 1#3”、“Node 2#1”、“Node 2#2”、“Node 2#3”的哈希值，于是形成六个虚拟节点</span><style>.spoiler{color:#000;background-color:#000;white-space:pre-line}.spoiler:hover{color:#fff}</style><h1 id=优化篇>优化篇</h1><h2 id=开发层次有哪些常用的优化建议>开发层次有哪些常用的优化建议</h2><ul><li><p>key的长度尽量要短，在数据量非常大时，过长的key名会占用更多的内存；</p></li><li><p>一定避免存储过大的数据（大value），过大的数据在分配内存和释放内存时耗时严重，会阻塞主线程；</p></li><li><p>Redis 4.0以上建议开启lazy-free机制，释放大value时异步操作，不阻塞主线程；</p></li><li><p>建议设置过期时间，把Redis当做缓存使用，尤其在数量很大的时，不设置过期时间会导致内存的无限增长；</p></li><li><p>不使用复杂度过高的命令，例如SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE，使用这些命令耗时较久，会阻塞主线程；</p></li><li><p>查询数据时，一次尽量获取较少的数据，在不确定容器元素个数的情况下，避免使用LRANGE key 0 -1，ZRANGE key 0 -1这类操作，应该设置具体查询的元素个数，推荐一次查询100个以下元素；</p></li><li><p>写入数据时，一次尽量写入较少的数据，例如HSET key value1 value2 value3…，控制一次写入元素的数量，推荐在100以下，大数据量分多个批次写入；</p></li><li><p>批量操作数据时，用MGET/MSET替换GET/SET、HMGET/MHSET替换HGET/HSET，减少请求来回的网络IO次数，降低延迟，对于没有批量操作的命令，推荐使用pipeline，一次性发送多个命令到服务端；</p></li><li><p>禁止使用KEYS命令，需要扫描实例时，建议使用SCAN，线上操作一定要控制扫描的频率，避免对Redis产生性能抖动</p></li><li><p>避免某个时间点集中过期大量的key，集中过期时推荐增加一个随机时间，把过期时间打散，降低集中过期key时Redis的压力，避免阻塞主线程；</p></li><li><p>根据业务场景，选择合适的淘汰策略，通常随机过期要比LRU过期淘汰数据更快；</p></li><li><p>使用连接池访问Redis，并配置合理的连接池参数，避免短连接，TCP三次握手和四次挥手的耗时也很高；</p></li><li><p>只使用db0，不推荐使用多个db，使用多个db会增加Redis的负担，每次访问不同的db都需要执行SELECT命令，如果业务线不同，建议拆分多个实例，还能提高单个实例的性能；</p></li><li><p>读的请求量很大时，推荐使用读写分离，前提是可以容忍从节数据更新不及时的问题；</p></li><li><p>写请求量很大时，推荐使用集群，部署多个实例分摊写压力</p><h2 id=运维层次有哪些常用的优化建议>运维层次有哪些常用的优化建议</h2></li><li><p>不同业务线部署不同的实例，各自独立，避免混用，推荐不同业务线使用不同的机器，根据业务重要程度划分不同的分组来部署，避免某一个业务线出现问题影响其他业务线；</p></li><li><p>保证机器有足够的CPU、内存、带宽、磁盘资源，防止负载过高影响Redis性能；</p></li><li><p>以master-slave集群方式部署实例，并分布在不同机器上，避免单点，slave必须设置为readonly；
master和slave节点所在机器，各自独立，不要交叉部署实例，通常备份工作会在slave上做，做备份时会消耗机器资源，交叉部署会影响到master的性能；</p></li><li><p>推荐部署哨兵节点增加可用性，节点数量至少3个，并分布在不同机器上，实现故障自动故障转移；</p></li><li><p>提前做好容量规划，一台机器部署实例的内存上限，最好是机器内存的一半，主从全量同步时会占用最多额外一倍的内存空间，防止网络大面积故障引发所有master-slave的全量同步导致机器内存被吃光；</p></li><li><p>做好机器的CPU、内存、带宽、磁盘监控，在资源不足时及时报警处理，Redis使用Swap后性能急剧下降，网络带宽负载过高访问延迟明显增大，磁盘IO过高时开启AOF会拖慢Redis的性能；</p></li><li><p>设置最大连接数上限，防止过多的客户端连接导致服务负载过高；</p></li><li><p>单个实例的使用内存建议控制在10G以下，过大的实例会导致备份时间久、资源消耗多，主从全量同步数据时间阻塞时间更长；</p></li><li><p>设置合理的slowlog阈值，推荐10毫秒，并对其进行监控，产生过多的慢日志需要及时报警；</p></li><li><p>设置合理的复制缓冲区repl-backlog大小，适当调大repl-backlog可以降低主从全量复制的概率；</p></li><li><p>设置合理的slave节点client-output-buffer-limit大小，对于写入量很大的实例，适当调大可以避免主从复制中断问题；</p></li><li><p>备份时推荐在slave节点上做，不影响master性能；</p></li><li><p>不开启AOF或开启AOF配置为每秒刷盘，避免磁盘IO消耗降低Redis性能；</p></li><li><p>当实例设置了内存上限，需要调大内存上限时，先调整slave再调整master，否则会导致主从节点数据不一致；</p></li><li><p>对Redis增加监控，监控采集info信息时，使用长连接，频繁的短连接也会影响Redis性能；</p></li><li><p>线上扫描整个实例数时，记得设置休眠时间，避免扫描时QPS突增对Redis产生性能抖动；</p></li><li><p>做好Redis的运行时监控，尤其是expired_keys、evicted_keys、latest_fork_usec指标，短时间内这些指标值突增可能会阻塞整个实例，引发性能问题</p></li></ul></div><footer class=post-footer><div class=post-tags><a href=https://1162492411.github.io/docs/tags/redis rel=tag title=Redis>#Redis#</a>
<a href=https://1162492411.github.io/docs/tags/%e4%b8%ad%e9%97%b4%e4%bb%b6 rel=tag title=中间件>#中间件#</a>
<a href=https://1162492411.github.io/docs/tags/nosql rel=tag title=NoSQL>#NoSQL#</a>
<a href=https://1162492411.github.io/docs/tags/%e6%95%b0%e6%8d%ae%e5%ba%93 rel=tag title=数据库>#数据库#</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://1162492411.github.io/docs/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/ rel=next title=数据库常见面试题><i class="fa fa-chevron-left"></i>数据库常见面试题</a></div><div class="post-nav-prev post-nav-item"><a href=https://1162492411.github.io/docs/post/mysql%E6%8E%92%E4%BB%96%E9%94%81%E5%AE%9E%E6%88%98/ rel=prev title=MySQL排他锁实战>MySQL排他锁实战 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=https://1162492411.github.io/docs/img/author.jpg alt=zyg><p class=site-author-name itemprop=name>zyg</p><p class="site-description motion-element" itemprop=description>Programmer & Architect</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=https://1162492411.github.io/docs/post/><span class=site-state-item-count>28</span>
<span class=site-state-item-name></span></a></div><div class="site-state-item site-state-categories"><a href=https://1162492411.github.io/docs/categories/><span class=site-state-item-count>27</span>
<span class=site-state-item-name></span></a></div><div class="site-state-item site-state-tags"><a href=https://1162492411.github.io/docs/tags/><span class=site-state-item-count>47</span>
<span class=site-state-item-name></span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/1162492411/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span></div><div class="links-of-blogroll motion-element inline"><script type=text/javascript src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&m=0&s=220&c=ff0000&cr1=ffffff&f=arial&l=33&bv=35" async></script></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span itemprop=copyrightYear>&copy;
2009 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span><span class=author itemprop=copyrightHolder></span></div><div class=powered-by>Powered by - <a class=theme-link href=http://gohugo.io target=_blank title=hugo>Hugo v0.68.3</a></div><div class=theme-info>Theme by - <a class=theme-link href=https://github.com/xtfly/hugo-theme-next target=_blank>NexT</a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i><span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript>if(Object.prototype.toString.call(window.Promise)!=='[object Function]'){window.Promise=null;}</script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/jquery/index.js?v=2.1.3"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/velocity/velocity.min.js?v=1.2.1"></script><script type=text/javascript src="https://1162492411.github.io/docs/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="https://1162492411.github.io/docs/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="https://1162492411.github.io/docs/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script><script type=text/javascript src=https://1162492411.github.io/docs/js/utils.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/motion.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/affix.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/schemes/pisces.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/scrollspy.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/post-details.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/toc.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/bootstrap.js></script><script type=text/javascript src=https://1162492411.github.io/docs/js/search.js></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>